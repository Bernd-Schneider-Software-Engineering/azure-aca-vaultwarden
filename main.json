{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "metadata": {
    "_generator": {
      "name": "bicep",
      "version": "0.39.26.7824",
      "templateHash": "14479989883472160647"
    }
  },
  "parameters": {
    "location": {
      "type": "string",
      "defaultValue": "[resourceGroup().location]",
      "metadata": {
        "description": "Azure region for all resources"
      }
    },
    "environment": {
      "type": "string",
      "defaultValue": "prod",
      "allowedValues": [
        "prod",
        "test",
        "dev"
      ],
      "metadata": {
        "description": "Kosten/Zuordnung: Umgebung (prod/test/dev)"
      }
    },
    "bsseRef": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Traceability: BSSE Deploy-Ref (z.B. Git Tag oder Commit SHA)"
      }
    },
    "appName": {
      "type": "string",
      "defaultValue": "vault",
      "metadata": {
        "description": "Name of the Vaultwarden Container App"
      }
    },
    "domainUrl": {
      "type": "string",
      "metadata": {
        "description": "Public URL of your Vaultwarden instance. MUST include https:// (example: https://sub.domain.tld)"
      }
    },
    "allowInsecureHttp": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Allow insecure HTTP traffic (recommended: false for production)"
      }
    },
    "startPaused": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "If true, deploy the Container App with minReplicas=0 (paused, no instances running). NOTE: For Azure managed certificates / domain validation the app must be reachable, so set this to false during certificate provisioning."
      }
    },
    "vaultwardenImage": {
      "type": "string",
      "defaultValue": "vaultwarden/server:1.35.2-alpine",
      "metadata": {
        "description": "Container image to use for Vaultwarden (pin a version for reproducible deployments)"
      }
    },
    "cpuCores": {
      "type": "string",
      "defaultValue": "0.25",
      "metadata": {
        "description": "CPU cores for the container"
      }
    },
    "memorySize": {
      "type": "string",
      "defaultValue": "0.5",
      "metadata": {
        "description": "Memory in GiB for the container (CPU:RAM ratio must be 1:2)"
      }
    },
    "storageAccountSku": {
      "type": "string",
      "defaultValue": "Standard_LRS",
      "allowedValues": [
        "Standard_LRS",
        "Standard_ZRS",
        "Standard_GRS",
        "Standard_RAGRS",
        "Standard_GZRS",
        "Standard_RAGZRS"
      ],
      "metadata": {
        "description": "Storage account SKU for Azure Files"
      }
    },
    "postgresSkuName": {
      "type": "string",
      "defaultValue": "Standard_B1ms",
      "metadata": {
        "description": "PostgreSQL SKU name"
      }
    },
    "postgresStorageGB": {
      "type": "int",
      "defaultValue": 32,
      "metadata": {
        "description": "PostgreSQL storage size in GB"
      }
    },
    "allowAzureServicesToPostgres": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Allow Azure services to access PostgreSQL (0.0.0.0 firewall rule). Recommended: true for Container Apps without VNet/NAT."
      }
    },
    "dbAdminUser": {
      "type": "string",
      "defaultValue": "vaultwarden",
      "metadata": {
        "description": "PostgreSQL admin username"
      }
    },
    "dbPassword": {
      "type": "securestring",
      "metadata": {
        "description": "PostgreSQL admin password (auto-generated by default). NOT stored in Key Vault."
      },
      "defaultValue": "[concat(toUpper(newGuid()), newGuid())]"
    },
    "invitationOrgName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Organization name shown in invitation emails (INVITATION_ORG_NAME)"
      }
    },
    "signupsDomainsWhitelist": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Comma-separated email domain whitelist for signups (SIGNUPS_DOMAINS_WHITELIST)"
      }
    },
    "smtpUseAuth": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Wenn true, nutzt Vaultwarden SMTP Submission mit Auth (SMTP_USERNAME/SMTP_PASSWORD). Wenn false, wird Direct Send ohne Auth verwendet."
      }
    },
    "smtpFrom": {
      "type": "string",
      "metadata": {
        "description": "SMTP FROM address (e.g. vaultwarden@domain.tld)"
      },
      "defaultValue": ""
    },
    "smtpFromName": {
      "type": "string",
      "defaultValue": "Vaultwarden",
      "metadata": {
        "description": "Anzeigename im From-Header."
      }
    },
    "heloName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Servername im SMTP HELO/EHLO. Leer lassen = Hostname aus DOMAIN-URL."
      }
    },
    "smtpHost": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional: SMTP Host Override. Leer lassen = Direct Send: MX Lookup aus der Domain von domainUrl; SMTP Auth: smtp.office365.com."
      }
    },
    "smtpPort": {
      "type": "string",
      "defaultValue": "587",
      "metadata": {
        "description": "SMTP port (M365 default: 587)"
      }
    },
    "smtpSecurity": {
      "type": "string",
      "defaultValue": "starttls",
      "allowedValues": [
        "starttls",
        "force_tls",
        "off"
      ],
      "metadata": {
        "description": "SMTP security (starttls / force_tls / off)"
      }
    },
    "smtpUsername": {
      "type": "string",
      "metadata": {
        "description": "SMTP username (often same as smtpFrom)"
      },
      "defaultValue": ""
    },
    "smtpPassword": {
      "type": "securestring",
      "metadata": {
        "description": "SMTP password"
      },
      "defaultValue": ""
    },
    "smtpAuthMechanism": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional (nur SMTP Auth): SMTP Auth Mechanism. M\u00f6gliche Werte u.a.: Plain, Login, Xoauth2 (auch kommasepariert)."
      },
      "allowedValues": [
        "",
        "Plain",
        "Login",
        "Xoauth2",
        "Plain,Login",
        "Login,Plain"
      ]
    },
    "azureFilesBackupEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Enable Azure Backup for the Azure File Share used by Vaultwarden (/data)."
      }
    },
    "azureFilesBackupScheduleRunTime": {
      "type": "string",
      "defaultValue": "05:30",
      "metadata": {
        "description": "Time of day (HH:MM) when backup should run. MM must be 00 or 30."
      }
    },
    "azureFilesBackupTimeZone": {
      "type": "string",
      "defaultValue": "UTC",
      "metadata": {
        "description": "Windows timezone name for the backup schedule, e.g. UTC, W. Europe Standard Time."
      }
    },
    "azureFilesBackupDailyRetentionDays": {
      "type": "int",
      "defaultValue": 30,
      "metadata": {
        "description": "Number of days to retain daily Azure Files backups."
      }
    },
    "azureFilesBackupWeeklyDaysOfWeek": {
      "type": "array",
      "defaultValue": [
        "Sunday",
        "Tuesday",
        "Thursday"
      ],
      "metadata": {
        "description": "Days of week used for weekly retention points."
      }
    },
    "azureFilesBackupWeeklyRetentionWeeks": {
      "type": "int",
      "defaultValue": 12,
      "metadata": {
        "description": "Number of weeks to retain weekly Azure Files backups."
      }
    },
    "smtpAuthPreset": {
      "type": "string",
      "defaultValue": "custom",
      "allowedValues": [
        "custom",
        "acsSmtp"
      ],
      "metadata": {
        "description": "SMTP-Auth Preset. custom = nutze smtpHost/smtpPort/smtpSecurity wie angegeben. acsSmtp = nutze Azure Communication Services Email (SMTP) (Host/Port/Security werden automatisch gesetzt, ACS Ressourcen werden mitdeployt). Wirksam nur wenn smtpUseAuth=true."
      }
    },
    "acsDataLocation": {
      "type": "string",
      "defaultValue": "Germany",
      "metadata": {
        "description": "ACS Data Location (z.B. Germany, Europe, UnitedStates). Nur relevant f\u00fcr smtpAuthPreset=acsSmtp."
      }
    },
    "acsDomainName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Domain, die in ACS Email verifiziert werden soll (z.B. domain.tld). Leer = versucht domainRootDefault aus domainUrl zu verwenden. Nur relevant f\u00fcr smtpAuthPreset=acsSmtp."
      }
    },
    "acsDomainManagement": {
      "type": "string",
      "defaultValue": "CustomerManaged",
      "allowedValues": [
        "CustomerManaged",
        "CustomerManagedInExchangeOnline"
      ],
      "metadata": {
        "description": "ACS Email Domain Management. CustomerManaged (DNS Records manuell setzen) oder CustomerManagedInExchangeOnline (wenn Exchange Online genutzt wird). Nur relevant f\u00fcr smtpAuthPreset=acsSmtp."
      }
    },
    "acsEntraApplicationId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Entra ID Application (Client) ID der App Registration, die f\u00fcr ACS SMTP verwendet wird. Nur relevant f\u00fcr smtpAuthPreset=acsSmtp."
      }
    },
    "acsEntraTenantId": {
      "type": "string",
      "defaultValue": "[subscription().tenantId]",
      "metadata": {
        "description": "Entra Tenant ID. Standard = subscription().tenantId. Nur relevant f\u00fcr smtpAuthPreset=acsSmtp."
      }
    },
    "acsEntraServicePrincipalObjectId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Object ID des Service Principals der obigen Entra App (wird f\u00fcr RBAC Role Assignment auf dem ACS Communication Service genutzt). Nur relevant f\u00fcr smtpAuthPreset=acsSmtp."
      }
    }
  },
  "variables": {
    "templateLinkUri": "[if(contains(deployment().properties,'templateLink'), if(contains(deployment().properties.templateLink,'uri'), deployment().properties.templateLink.uri, ''), '')]",
    "templateLinkRefRaw": "[if(contains(variables('templateLinkUri'), 'raw.githubusercontent.com'), split(variables('templateLinkUri'), '/')[5], variables('templateLinkUri'))]",
    "bsseRefRaw": "[if(empty(parameters('bsseRef')), if(empty(variables('templateLinkRefRaw')), 'local', variables('templateLinkRefRaw')), parameters('bsseRef'))]",
    "bsseRefEffective": "[if(empty(variables('bsseRefRaw')), '', substring(variables('bsseRefRaw'), 0, min(length(variables('bsseRefRaw')), 256)))]",
    "commonTags": "[createObject('Environment', parameters('environment'), 'bsse:ref', variables('bsseRefEffective'))]",
    "storageAccountName": "[toLower(format('{0}files{1}', parameters('appName'), uniqueString(resourceGroup().id)))]",
    "fileShareName": "vaultwarden",
    "postgresServerName": "[toLower(format('{0}-pg-{1}', parameters('appName'), uniqueString(resourceGroup().id)))]",
    "postgresDbName": "vaultwarden",
    "postgresFqdn": "[format('{0}.postgres.database.azure.com', variables('postgresServerName'))]",
    "postgresPort": "5432",
    "dbAppUser": "vw_app",
    "kvSecretDbAppPasswordName": "vw-db-app-password",
    "logAnalyticsName": "[format('{0}-law', parameters('appName'))]",
    "containerEnvName": "[format('{0}-env', parameters('appName'))]",
    "keyVaultName": "[toLower(format('vwkv{0}{1}', uniqueString(resourceGroup().id), substring(uniqueString(deployment().name),0,4)))]",
    "kvSecretAdminTokenName": "vw-admin-token",
    "kvSecretDatabaseUrlName": "vw-database-url",
    "kvSecretSmtpPasswordName": "vw-smtp-password",
    "roleKeyVaultSecretsOfficer": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'b86a8fe4-44ce-4948-aee5-eccb2c155cd7')]",
    "roleKeyVaultSecretsUser": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '4633458b-17de-408a-b874-0445c86b69e6')]",
    "domainHostDefault": "[split(replace(replace(parameters('domainUrl'),'https://',''),'http://',''),'/')[0]]",
    "domainHostParts": "[split(variables('domainHostDefault'),'.')]",
    "domainRootDefault": "[if(greaterOrEquals(length(variables('domainHostParts')), 2), concat(variables('domainHostParts')[sub(length(variables('domainHostParts')),2)],'.',variables('domainHostParts')[sub(length(variables('domainHostParts')),1)]),variables('domainHostDefault'))]",
    "vwEnvBase": [
      {
        "name": "ADMIN_TOKEN",
        "secretRef": "admin-token"
      },
      {
        "name": "DATABASE_URL",
        "secretRef": "database-url"
      },
      {
        "name": "DOMAIN",
        "value": "[parameters('domainUrl')]"
      },
      {
        "name": "EMAIL_2FA_AUTO_FALLBACK",
        "value": "false"
      },
      {
        "name": "HTTP_REQUEST_BLOCK_NON_GLOBAL_IPS",
        "value": "true"
      },
      {
        "name": "INVITATIONS_ALLOWED",
        "value": "true"
      },
      {
        "name": "INVITATION_ORG_NAME",
        "value": "[parameters('invitationOrgName')]"
      },
      {
        "name": "SHOW_PASSWORD_HINT",
        "value": "false"
      },
      {
        "name": "SIGNUPS_ALLOWED",
        "value": "false"
      },
      {
        "name": "SIGNUPS_DOMAINS_WHITELIST",
        "value": "[parameters('signupsDomainsWhitelist')]"
      }
    ],
    "vwEnvSmtpCommon": [
      {
        "name": "SMTP_FROM",
        "value": "[if(empty(parameters('smtpFrom')), format('vault@{0}', variables('domainRootDefault')), parameters('smtpFrom'))]"
      },
      {
        "name": "SMTP_FROM_NAME",
        "value": "[parameters('smtpFromName')]"
      },
      {
        "name": "HELO_NAME",
        "value": "[if(empty(parameters('heloName')), variables('domainHostDefault'), parameters('heloName'))]"
      },
      {
        "name": "SMTP_HOST",
        "value": "[if(variables('useAcsSmtp'), 'smtp.azurecomm.net', if(parameters('smtpUseAuth'), if(empty(parameters('smtpHost')), 'smtp.office365.com', parameters('smtpHost')), reference(resourceId('Microsoft.Resources/deploymentScripts', variables('deploymentScriptName')), variables('deploymentScriptApiVersion')).outputs.smtp_host))]"
      },
      {
        "name": "SMTP_PORT",
        "value": "[if(variables('useAcsSmtp'), '587', if(parameters('smtpUseAuth'), string(parameters('smtpPort')), '25'))]"
      },
      {
        "name": "SMTP_SECURITY",
        "value": "[if(variables('useAcsSmtp'), 'starttls', if(parameters('smtpUseAuth'), parameters('smtpSecurity'), 'starttls'))]"
      }
    ],
    "vwEnvSmtpAuthCore": [
      {
        "name": "SMTP_USERNAME",
        "value": "[parameters('smtpUsername')]"
      },
      {
        "name": "SMTP_PASSWORD",
        "secretRef": "smtp-password"
      }
    ],
    "vwSecretsBase": [
      {
        "name": "admin-token",
        "keyVaultUrl": "[format('https://{0}.vault.azure.net/secrets/{1}', variables('keyVaultName'), variables('kvSecretAdminTokenName'))]",
        "identity": "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-id', parameters('appName')))]"
      },
      {
        "name": "database-url",
        "keyVaultUrl": "[format('https://{0}.vault.azure.net/secrets/{1}', variables('keyVaultName'), variables('kvSecretDatabaseUrlName'))]",
        "identity": "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-id', parameters('appName')))]"
      }
    ],
    "vwSecretsSmtp": [
      {
        "name": "smtp-password",
        "keyVaultUrl": "[format('https://{0}.vault.azure.net/secrets/{1}', variables('keyVaultName'), variables('kvSecretSmtpPasswordName'))]",
        "identity": "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-id', parameters('appName')))]"
      }
    ],
    "recoveryServicesVaultName": "[format('{0}-rsv', variables('namePrefix'))]",
    "azureFilesBackupFabric": "Azure",
    "azureFilesBackupManagementType": "AzureStorage",
    "azureFilesBackupPolicyName": "[format('{0}-afiles-daily', variables('namePrefix'))]",
    "azureFilesBackupScheduleRunTimes": [
      "[format('2020-01-01T{0}:00Z', parameters('azureFilesBackupScheduleRunTime'))]"
    ],
    "azureFilesBackupTimeZone": "[parameters('azureFilesBackupTimeZone')]",
    "azureFilesBackupDailyRetentionDurationCount": "[parameters('azureFilesBackupDailyRetentionDays')]",
    "azureFilesBackupDaysOfTheWeek": "[parameters('azureFilesBackupWeeklyDaysOfWeek')]",
    "azureFilesBackupWeeklyRetentionDurationCount": "[parameters('azureFilesBackupWeeklyRetentionWeeks')]",
    "useAcsSmtp": "[and(parameters('smtpUseAuth'), equals(parameters('smtpAuthPreset'), 'acsSmtp'))]",
    "acsEmailServiceName": "[toLower(format('{0}-email-{1}', parameters('appName'), substring(uniqueString(resourceGroup().id), 0, 6)))]",
    "acsDomainNameEffective": "[if(empty(parameters('acsDomainName')), variables('domainRootDefault'), parameters('acsDomainName'))]",
    "acsSenderUsername": "[toLower(split(parameters('smtpFrom'), '@')[0])]",
    "acsSenderDisplayName": "[format('{0} Vaultwarden', parameters('appName'))]",
    "acsCommunicationServiceName": "[toLower(format('{0}-acs-{1}', parameters('appName'), substring(uniqueString(resourceGroup().id), 0, 6)))]",
    "acsSmtpCustomRoleGuid": "[guid(resourceGroup().id, 'AcsEmailSmtpSenderRole')]",
    "acsSmtpCustomRoleId": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', variables('acsSmtpCustomRoleGuid'))]",
    "namePrefix": "[toLower(format('{0}{1}', parameters('appName'), substring(uniqueString(resourceGroup().id),0,6)))]",
    "deploymentScriptName": "[format('{0}-ensure-kv-secrets', parameters('appName'))]",
    "deploymentScriptApiVersion": "2023-08-01"
  },
  "resources": [
    {
      "type": "Microsoft.OperationalInsights/workspaces",
      "apiVersion": "2023-09-01",
      "name": "[variables('logAnalyticsName')]",
      "location": "[parameters('location')]",
      "properties": {
        "retentionInDays": 30
      },
      "tags": "[variables('commonTags')]"
    },
    {
      "type": "Microsoft.Storage/storageAccounts",
      "apiVersion": "2023-05-01",
      "name": "[variables('storageAccountName')]",
      "location": "[parameters('location')]",
      "sku": {
        "name": "[parameters('storageAccountSku')]"
      },
      "kind": "StorageV2",
      "properties": {
        "allowBlobPublicAccess": false,
        "minimumTlsVersion": "TLS1_2",
        "supportsHttpsTrafficOnly": true
      },
      "tags": "[variables('commonTags')]"
    },
    {
      "type": "Microsoft.Storage/storageAccounts/fileServices",
      "apiVersion": "2023-05-01",
      "name": "[format('{0}/{1}', variables('storageAccountName'), 'default')]",
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ]
    },
    {
      "type": "Microsoft.Storage/storageAccounts/fileServices/shares",
      "apiVersion": "2023-05-01",
      "name": "[format('{0}/{1}/{2}', variables('storageAccountName'), 'default', variables('fileShareName'))]",
      "properties": {
        "accessTier": "Hot"
      },
      "dependsOn": [
        "[resourceId('Microsoft.Storage/storageAccounts/fileServices', variables('storageAccountName'), 'default')]"
      ]
    },
    {
      "type": "Microsoft.KeyVault/vaults",
      "apiVersion": "2023-07-01",
      "name": "[variables('keyVaultName')]",
      "location": "[parameters('location')]",
      "properties": {
        "tenantId": "[subscription().tenantId]",
        "sku": {
          "family": "A",
          "name": "standard"
        },
        "enableRbacAuthorization": true,
        "enabledForDeployment": false,
        "enabledForTemplateDeployment": true,
        "enabledForDiskEncryption": false,
        "publicNetworkAccess": "Enabled",
        "softDeleteRetentionInDays": 90,
        "enablePurgeProtection": true
      },
      "tags": "[variables('commonTags')]"
    },
    {
      "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
      "apiVersion": "2023-01-31",
      "name": "[format('{0}-id', parameters('appName'))]",
      "location": "[parameters('location')]",
      "tags": "[variables('commonTags')]"
    },
    {
      "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
      "apiVersion": "2023-01-31",
      "name": "[format('{0}-kv-writer-id', parameters('appName'))]",
      "location": "[parameters('location')]",
      "tags": "[variables('commonTags')]"
    },
    {
      "type": "Microsoft.Authorization/roleAssignments",
      "apiVersion": "2022-04-01",
      "scope": "[format('Microsoft.KeyVault/vaults/{0}', variables('keyVaultName'))]",
      "name": "[guid(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-kv-writer-id', parameters('appName'))), variables('roleKeyVaultSecretsOfficer'))]",
      "properties": {
        "roleDefinitionId": "[variables('roleKeyVaultSecretsOfficer')]",
        "principalId": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-kv-writer-id', parameters('appName'))), '2023-01-31').principalId]",
        "principalType": "ServicePrincipal"
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]",
        "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-kv-writer-id', parameters('appName')))]"
      ]
    },
    {
      "type": "Microsoft.Authorization/roleAssignments",
      "apiVersion": "2022-04-01",
      "scope": "[format('Microsoft.KeyVault/vaults/{0}', variables('keyVaultName'))]",
      "name": "[guid(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-id', parameters('appName'))), variables('roleKeyVaultSecretsUser'))]",
      "properties": {
        "roleDefinitionId": "[variables('roleKeyVaultSecretsUser')]",
        "principalId": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-id', parameters('appName'))), '2023-01-31').principalId]",
        "principalType": "ServicePrincipal"
      },
      "dependsOn": [
        "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-id', parameters('appName')))]",
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deploymentScripts",
      "apiVersion": "2023-08-01",
      "name": "[format('{0}-ensure-kv-secrets', parameters('appName'))]",
      "location": "[parameters('location')]",
      "kind": "AzureCLI",
      "identity": {
        "type": "UserAssigned",
        "userAssignedIdentities": {
          "[format('{0}', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-kv-writer-id', parameters('appName'))))]": {}
        }
      },
      "properties": {
        "azCliVersion": "2.82.0",
        "timeout": "PT30M",
        "retentionInterval": "P1D",
        "cleanupPreference": "OnSuccess",
        "environmentVariables": [
          {
            "name": "KEYVAULT_NAME",
            "value": "[variables('keyVaultName')]"
          },
          {
            "name": "ADMIN_TOKEN_SECRET",
            "value": "[variables('kvSecretAdminTokenName')]"
          },
          {
            "name": "SMTP_PASSWORD_SECRET",
            "value": "[variables('kvSecretSmtpPasswordName')]"
          },
          {
            "name": "SMTP_PASSWORD_VALUE",
            "secureValue": "[parameters('smtpPassword')]"
          },
          {
            "name": "DATABASE_URL_SECRET",
            "value": "[variables('kvSecretDatabaseUrlName')]"
          },
          {
            "name": "POSTGRES_FQDN",
            "value": "[variables('postgresFqdn')]"
          },
          {
            "name": "POSTGRES_PORT",
            "value": "[string(variables('postgresPort'))]"
          },
          {
            "name": "POSTGRES_DBNAME",
            "value": "[variables('postgresDbName')]"
          },
          {
            "name": "DB_ADMIN_USER",
            "value": "[parameters('dbAdminUser')]"
          },
          {
            "name": "TLS_SSLMODE",
            "value": "require"
          },
          {
            "name": "POSTGRES_SERVER_NAME",
            "value": "[variables('postgresServerName')]"
          },
          {
            "name": "DB_ADMIN_PASSWORD",
            "secureValue": "[parameters('dbPassword')]"
          },
          {
            "name": "DB_APP_USER",
            "value": "[variables('dbAppUser')]"
          },
          {
            "name": "DB_APP_PASSWORD_SECRET",
            "value": "[variables('kvSecretDbAppPasswordName')]"
          },
          {
            "name": "UAMI_CLIENT_ID",
            "value": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-kv-writer-id', parameters('appName'))), '2018-11-30').clientId]"
          },
          {
            "name": "SMTP_USE_AUTH",
            "value": "[string(parameters('smtpUseAuth'))]"
          },
          {
            "name": "SMTP_HOST_INPUT",
            "value": "[parameters('smtpHost')]"
          },
          {
            "name": "DOMAIN_URL",
            "value": "[parameters('domainUrl')]"
          }
        ],
        "scriptContent": "set -euo pipefail\n\necho \"[vault-ensure-kv-secrets] ensuring Key Vault secrets exist in $KEYVAULT_NAME ...\"\n\n# Ensure we are authenticated (deploymentScripts should use the assigned managed identity, but harden against missing session)\nif ! az account show 1>/dev/null 2>/dev/null; then\n  echo \"[vault-ensure-kv-secrets] az account not available - logging in with managed identity\"\n  if [ -n \"${UAMI_CLIENT_ID:-}\" ]; then\n    az login --identity --client-id \"$UAMI_CLIENT_ID\" 1>/dev/null\n  else\n    az login --identity 1>/dev/null\n  fi\nfi\n\n# ------------------------------------------------------------\n# PostgreSQL tooling\n# ------------------------------------------------------------\n# Prefer psql, but deploymentScripts can run on different Linux base images where package managers vary.\n# If we cannot install psql, fall back to a pure-Python driver (pg8000).\n\nUSE_PYPG=0\n\nif ! command -v psql 1>/dev/null 2>/dev/null; then\n  echo \"[vault-ensure-kv-secrets] psql not found - attempting to install PostgreSQL client\"\n  echo \"[vault-ensure-kv-secrets] OS info:\"\n  (cat /etc/os-release || true) | sed 's/^/[vault-ensure-kv-secrets]   /'\n\n  echo \"[vault-ensure-kv-secrets] Detected package managers:\"\n  for c in apk tdnf apt-get yum dnf microdnf; do\n    if command -v \"$c\" 1>/dev/null 2>/dev/null; then\n      echo \"[vault-ensure-kv-secrets]   - $c\"\n    fi\n  done\n\n  if command -v apk 1>/dev/null 2>/dev/null; then\n    echo \"[vault-ensure-kv-secrets] installing via apk ...\"\n    apk update\n    apk add --no-cache postgresql-client 2>/dev/null || apk add --no-cache postgresql\n  elif command -v tdnf 1>/dev/null 2>/dev/null; then\n    echo \"[vault-ensure-kv-secrets] installing via tdnf ...\"\n    tdnf install -y postgresql 2>/dev/null || tdnf install -y postgresql-client\n  elif command -v apt-get 1>/dev/null 2>/dev/null; then\n    echo \"[vault-ensure-kv-secrets] installing via apt-get ...\"\n    if [ \"$(id -u)\" -ne 0 ] && command -v sudo 1>/dev/null 2>/dev/null; then\n      SUDO=\"sudo\"\n    else\n      SUDO=\"\"\n    fi\n    $SUDO apt-get update -y\n    $SUDO apt-get install -y postgresql-client\n  elif command -v yum 1>/dev/null 2>/dev/null; then\n    echo \"[vault-ensure-kv-secrets] installing via yum ...\"\n    yum install -y postgresql\n  elif command -v dnf 1>/dev/null 2>/dev/null; then\n    echo \"[vault-ensure-kv-secrets] installing via dnf ...\"\n    dnf install -y postgresql\n  elif command -v microdnf 1>/dev/null 2>/dev/null; then\n    echo \"[vault-ensure-kv-secrets] installing via microdnf ...\"\n    microdnf install -y postgresql\n  else\n    echo \"[vault-ensure-kv-secrets] No supported package manager found. Falling back to pure-Python pg8000.\"\n    USE_PYPG=1\n  fi\n\n  if [ \"$USE_PYPG\" -eq 0 ] && ! command -v psql 1>/dev/null 2>/dev/null; then\n    echo \"[vault-ensure-kv-secrets] WARNING: psql install path did not yield psql. Falling back to pure-Python pg8000.\"\n    USE_PYPG=1\n  fi\nfi\n\n# If using python fallback, ensure pg8000 is available (pure python, no system libpq needed)\nif [ \"$USE_PYPG\" -eq 1 ]; then\n  echo \"[vault-ensure-kv-secrets] ensuring python driver pg8000 is available ...\"\n  python3 -m pip install --no-cache-dir -q pg8000\nfi\n\n# ------------------------------------------------------------\n# Wait for Key Vault RBAC/permissions to become effective\n# ------------------------------------------------------------\necho \"[vault-ensure-kv-secrets] waiting for Key Vault permissions...\"\nfor i in $(seq 1 30); do\n  if az keyvault secret list --vault-name \"$KEYVAULT_NAME\" --maxresults 1 1>/dev/null 2>/dev/null; then\n    echo \"[vault-ensure-kv-secrets] Key Vault access OK\"\n    break\n  fi\n  echo \"[vault-ensure-kv-secrets] Key Vault access not ready yet ($i/30), sleeping 10s...\"\n  sleep 10\n  if [ \"$i\" -eq 30 ]; then\n    echo \"[vault-ensure-kv-secrets] ERROR: Key Vault permissions not ready after 300s\"\n    exit 1\n  fi\ndone\n\n# ------------------------------------------------------------\n# Wait for PostgreSQL to accept connections\n# ------------------------------------------------------------\necho \"[vault-ensure-kv-secrets] waiting for PostgreSQL connectivity...\"\nexport PGPASSWORD=\"${DB_ADMIN_PASSWORD}\"\n\nif [ \"$USE_PYPG\" -eq 0 ]; then\n  PG_CONN_ADMIN=\"host=${POSTGRES_FQDN} port=${POSTGRES_PORT} dbname=postgres user=${DB_ADMIN_USER} sslmode=${TLS_SSLMODE}\"\n  for i in $(seq 1 30); do\n    if psql \"${PG_CONN_ADMIN}\" -v ON_ERROR_STOP=1 -c \"SELECT 1\" 1>/dev/null 2>/dev/null; then\n      echo \"[vault-ensure-kv-secrets] PostgreSQL reachable\"\n      break\n    fi\n    echo \"[vault-ensure-kv-secrets] PostgreSQL not ready yet ($i/30), sleeping 10s...\"\n    sleep 10\n    if [ \"$i\" -eq 30 ]; then\n      echo \"[vault-ensure-kv-secrets] ERROR: PostgreSQL not reachable after 300s\"\n      exit 1\n    fi\n  done\nelse\n  python3 - <<'PY'\nimport os, time, ssl\nimport pg8000\n\nhost=os.environ[\"POSTGRES_FQDN\"]\nport=int(os.environ.get(\"POSTGRES_PORT\",\"5432\"))\nuser=os.environ[\"DB_ADMIN_USER\"]\npw=os.environ[\"DB_ADMIN_PASSWORD\"]\ndb=\"postgres\"\n\n# Match \"sslmode=require\" semantics: encryption without hostname / chain validation\nctx=ssl.create_default_context()\nctx.check_hostname=False\nctx.verify_mode=ssl.CERT_NONE\n\nfor i in range(30):\n  try:\n    conn=pg8000.connect(host=host, port=port, user=user, password=pw, database=db, ssl_context=ctx, timeout=10)\n    conn.autocommit=True\n    cur=conn.cursor()\n    cur.execute(\"SELECT 1\")\n    cur.close()\n    conn.close()\n    print(\"[vault-ensure-kv-secrets] PostgreSQL reachable\")\n    break\n  except Exception as e:\n    print(f\"[vault-ensure-kv-secrets] PostgreSQL not ready yet ({i+1}/30): {e}\")\n    time.sleep(10)\nelse:\n  raise SystemExit(\"[vault-ensure-kv-secrets] ERROR: PostgreSQL not reachable after 300s\")\nPY\nfi\n\n# ------------------------------------------------------------\n# Secrets in Key Vault\n# ------------------------------------------------------------\n\n# --- ADMIN_TOKEN ---\nif az keyvault secret show --vault-name \"$KEYVAULT_NAME\" --name \"$ADMIN_TOKEN_SECRET\" 1>/dev/null 2>/dev/null; then\n  echo \"ADMIN_TOKEN secret already exists.\"\nelse\n  echo \"Creating ADMIN_TOKEN secret...\"\n  ADMIN_TOKEN=$(python3 - << 'PY'\nimport secrets, base64\nprint(base64.urlsafe_b64encode(secrets.token_bytes(48)).decode('utf-8').rstrip('='))\nPY\n)\n  az keyvault secret set --vault-name \"$KEYVAULT_NAME\" --name \"$ADMIN_TOKEN_SECRET\" --value \"$ADMIN_TOKEN\" 1>/dev/null\n  echo \"ADMIN_TOKEN secret created.\"\nfi\n\n# --- SMTP password ---\nif [ \"${SMTP_USE_AUTH:-false}\" = \"true\" ]; then\n  if az keyvault secret show --vault-name \"$KEYVAULT_NAME\" --name \"$SMTP_PASSWORD_SECRET\" 1>/dev/null 2>/dev/null; then\n    echo \"SMTP password secret already exists.\"\n  else\n    echo \"Creating SMTP password secret...\"\n    az keyvault secret set --vault-name \"$KEYVAULT_NAME\" --name \"$SMTP_PASSWORD_SECRET\" --value \"$SMTP_PASSWORD_VALUE\" 1>/dev/null\n    echo \"SMTP password secret created.\"\n  fi\nelse\n  echo \"SMTP auth disabled (Direct Send). Skipping SMTP password secret.\"\nfi\n\n# --- App DB password (least-privilege user for Vaultwarden) ---\nif az keyvault secret show --vault-name \"$KEYVAULT_NAME\" --name \"$DB_APP_PASSWORD_SECRET\" 1>/dev/null 2>/dev/null; then\n  echo \"App DB password secret already exists.\"\n  DB_APP_PASSWORD=$(az keyvault secret show --vault-name \"$KEYVAULT_NAME\" --name \"$DB_APP_PASSWORD_SECRET\" --query value -o tsv)\nelse\n  echo \"Creating App DB password secret...\"\n  DB_APP_PASSWORD=$(python3 - << 'PY'\nimport secrets\nprint(secrets.token_urlsafe(32))  # safe chars for SQL + URL encoding later\nPY\n)\n  az keyvault secret set --vault-name \"$KEYVAULT_NAME\" --name \"$DB_APP_PASSWORD_SECRET\" --value \"$DB_APP_PASSWORD\" 1>/dev/null\n  echo \"App DB password secret created.\"\nfi\n\nexport DB_APP_PASSWORD=\"$DB_APP_PASSWORD\"\n\n# ------------------------------------------------------------\n# Provision least-privilege role & grants (idempotent)\n# ------------------------------------------------------------\necho \"Provisioning Postgres role '$DB_APP_USER' and database privileges (idempotent) ...\"\n\nif [ \"$USE_PYPG\" -eq 0 ]; then\n  PG_CONN_ADMIN=\"host=${POSTGRES_FQDN} port=${POSTGRES_PORT} dbname=postgres user=${DB_ADMIN_USER} sslmode=${TLS_SSLMODE}\"\n  psql \"${PG_CONN_ADMIN}\" -v ON_ERROR_STOP=1 <<SQL 1>/dev/null\nDO \\$\\$\nBEGIN\n  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '${DB_APP_USER}') THEN\n    CREATE ROLE \"${DB_APP_USER}\" LOGIN PASSWORD '${DB_APP_PASSWORD}';\n  END IF;\nEND\n\\$\\$;\n\nALTER ROLE \"${DB_APP_USER}\"\n  WITH LOGIN PASSWORD '${DB_APP_PASSWORD}'\n  NOCREATEDB NOCREATEROLE NOINHERIT;\n\nGRANT CONNECT ON DATABASE \"${POSTGRES_DBNAME}\" TO \"${DB_APP_USER}\";\nSQL\n\n  PG_CONN_VWDB=\"host=${POSTGRES_FQDN} port=${POSTGRES_PORT} dbname=${POSTGRES_DBNAME} user=${DB_ADMIN_USER} sslmode=${TLS_SSLMODE}\"\n  psql \"${PG_CONN_VWDB}\" -v ON_ERROR_STOP=1 <<SQL 1>/dev/null\nGRANT USAGE, CREATE ON SCHEMA public TO \"${DB_APP_USER}\";\nSQL\nelse\n  python3 - <<'PY'\nimport os, ssl\nimport pg8000\n\nhost=os.environ[\"POSTGRES_FQDN\"]\nport=int(os.environ.get(\"POSTGRES_PORT\",\"5432\"))\nadmin_user=os.environ[\"DB_ADMIN_USER\"]\nadmin_pw=os.environ[\"DB_ADMIN_PASSWORD\"]\ndb_name=os.environ[\"POSTGRES_DBNAME\"]\napp_user=os.environ[\"DB_APP_USER\"]\napp_pw=os.environ[\"DB_APP_PASSWORD\"]\n\nctx=ssl.create_default_context()\nctx.check_hostname=False\nctx.verify_mode=ssl.CERT_NONE\n\ndef run(database, sql):\n  conn=pg8000.connect(host=host, port=port, user=admin_user, password=admin_pw, database=database, ssl_context=ctx, timeout=20)\n  conn.autocommit=True\n  cur=conn.cursor()\n  cur.execute(sql)\n  cur.close()\n  conn.close()\n\nsql_admin = (\n  \"DO $$\\n\"\n  \"BEGIN\\n\"\n  f\"  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '{app_user}') THEN\\n\"\n  f\"    CREATE ROLE \\\"{app_user}\\\" LOGIN PASSWORD '{app_pw}';\\n\"\n  \"  END IF;\\n\"\n  \"END\\n\"\n  \"$$;\\n\\n\"\n  f\"ALTER ROLE \\\"{app_user}\\\" WITH LOGIN PASSWORD '{app_pw}' NOCREATEDB NOCREATEROLE NOINHERIT;\\n\"\n  f\"GRANT CONNECT ON DATABASE \\\"{db_name}\\\" TO \\\"{app_user}\\\";\\n\"\n)\n\nrun(\"postgres\", sql_admin)\nrun(db_name, f\"GRANT USAGE, CREATE ON SCHEMA public TO \\\"{app_user}\\\";\")\n\nprint(\"Postgres provisioning done.\")\nPY\nfi\n\n# ------------------------------------------------------------\n# DATABASE_URL (PostgreSQL connection string for Vaultwarden)\n# ------------------------------------------------------------\nENCODED_APP_PASSWORD=$(python3 - << 'PY'\nimport os, urllib.parse\nprint(urllib.parse.quote(os.environ.get(\"DB_APP_PASSWORD\",\"\"), safe=\"\"))\nPY\n)\n\nDATABASE_URL=\"postgresql://${DB_APP_USER}:${ENCODED_APP_PASSWORD}@${POSTGRES_FQDN}:${POSTGRES_PORT}/${POSTGRES_DBNAME}?sslmode=${TLS_SSLMODE}\"\n\nif az keyvault secret show --vault-name \"$KEYVAULT_NAME\" --name \"$DATABASE_URL_SECRET\" 1>/dev/null 2>/dev/null; then\n  CURRENT_DBURL=$(az keyvault secret show --vault-name \"$KEYVAULT_NAME\" --name \"$DATABASE_URL_SECRET\" --query value -o tsv || echo \"\")\n  if echo \"$CURRENT_DBURL\" | grep -qiE '^postgres(ql)?://'; then\n    if echo \"$CURRENT_DBURL\" | grep -q \"://${DB_ADMIN_USER}:\"; then\n      echo \"DATABASE_URL currently uses admin user; updating to app user...\"\n      az keyvault secret set --vault-name \"$KEYVAULT_NAME\" --name \"$DATABASE_URL_SECRET\" --value \"$DATABASE_URL\" 1>/dev/null\n      echo \"DATABASE_URL secret updated.\"\n    else\n      echo \"DATABASE_URL secret already exists and looks valid.\"\n    fi\n  else\n    echo \"DATABASE_URL secret exists but looks invalid; updating to PostgreSQL URL...\"\n    az keyvault secret set --vault-name \"$KEYVAULT_NAME\" --name \"$DATABASE_URL_SECRET\" --value \"$DATABASE_URL\" 1>/dev/null\n    echo \"DATABASE_URL secret updated.\"\n  fi\nelse\n  echo \"Creating DATABASE_URL secret...\"\n  az keyvault secret set --vault-name \"$KEYVAULT_NAME\" --name \"$DATABASE_URL_SECRET\" --value \"$DATABASE_URL\" 1>/dev/null\n  echo \"DATABASE_URL secret created.\"\nfi\n\n# Non-sensitive output (for troubleshooting/visibility)\n\n# ------------------------------------------------------------\n# SMTP host resolution (Direct Send without auth)\n# ------------------------------------------------------------\n# Input:\n# - DOMAIN_URL: public URL of Vaultwarden (e.g. https://vault.kunde.tld)\n# - SMTP_HOST_INPUT: optional override for SMTP host\n#\n# Default behavior:\n# - SMTP Auth: smtp.office365.com (unless SMTP_HOST_INPUT is set)\n# - Direct Send: resolve MX of the derived base domain (unless SMTP_HOST_INPUT is set)\n\nDOMAIN_HOST=$(python3 - <<'PY'\nimport os, urllib.parse\nu=os.environ.get(\"DOMAIN_URL\",\"\").strip()\nif not u:\n    print(\"\")\n    raise SystemExit(0)\nif \"://\" not in u:\n    u=\"https://\"+u\np=urllib.parse.urlparse(u)\nprint(p.hostname or \"\")\nPY\n)\n\nBASE_DOMAIN=$(python3 - <<'PY'\nimport os\nhost=os.environ.get(\"DOMAIN_HOST\",\"\").strip()\nparts=[p for p in host.split(\".\") if p]\nif len(parts) >= 2:\n    print(\".\".join(parts[-2:]))\nelse:\n    print(host)\nPY\n)\n\nMX_HOST=\"\"\nif [ \"${SMTP_USE_AUTH:-false}\" = \"true\" ]; then\n  if [ -n \"${SMTP_HOST_INPUT:-}\" ]; then\n    MX_HOST=\"${SMTP_HOST_INPUT}\"\n  else\n    MX_HOST=\"smtp.office365.com\"\n  fi\nelse\n  if [ -n \"${SMTP_HOST_INPUT:-}\" ]; then\n    MX_HOST=\"${SMTP_HOST_INPUT}\"\n  else\n    if [ -z \"${BASE_DOMAIN}\" ]; then\n      echo \"[vault-ensure-kv-secrets] ERROR: Could not derive base domain from DOMAIN_URL='${DOMAIN_URL:-}'\"\n      exit 1\n    fi\n    echo \"[vault-ensure-kv-secrets] Resolving MX for ${BASE_DOMAIN} ...\"\n    python3 -m pip install --no-cache-dir -q dnspython\n    MX_HOST=$(python3 - <<'PY'\nimport os\nimport dns.resolver\ndomain=os.environ[\"BASE_DOMAIN\"]\nanswers=dns.resolver.resolve(domain, \"MX\")\nmx=sorted([(r.preference, str(r.exchange).rstrip(\".\")) for r in answers])[0][1]\nprint(mx)\nPY\n)\n  fi\nfi\necho \"[vault-ensure-kv-secrets] SMTP host resolved: ${MX_HOST}\"\n\n\ncat > \"$AZ_SCRIPTS_OUTPUT_PATH\" <<JSON\n{\n  \"status\": \"ok\",\n  \"smtp_host\": \"${MX_HOST}\"\n}\nJSON\n\necho \"Done.\"\n"
      },
      "dependsOn": [
        "[resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName'))]",
        "[extensionResourceId(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-kv-writer-id', parameters('appName'))), variables('roleKeyVaultSecretsOfficer')))]",
        "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-kv-writer-id', parameters('appName')))]",
        "[resourceId('Microsoft.DBforPostgreSQL/flexibleServers', variables('postgresServerName'))]",
        "[resourceId('Microsoft.DBforPostgreSQL/flexibleServers/databases', variables('postgresServerName'), variables('postgresDbName'))]"
      ]
    },
    {
      "type": "Microsoft.DBforPostgreSQL/flexibleServers",
      "apiVersion": "2023-03-01-preview",
      "name": "[variables('postgresServerName')]",
      "location": "[parameters('location')]",
      "sku": {
        "name": "[parameters('postgresSkuName')]",
        "tier": "Burstable"
      },
      "properties": {
        "administratorLogin": "[parameters('dbAdminUser')]",
        "administratorLoginPassword": "[parameters('dbPassword')]",
        "version": "15",
        "storage": {
          "storageSizeGB": "[parameters('postgresStorageGB')]"
        },
        "authConfig": {
          "passwordAuth": "Enabled",
          "activeDirectoryAuth": "Disabled"
        },
        "backup": {
          "backupRetentionDays": 7
        }
      },
      "tags": "[variables('commonTags')]"
    },
    {
      "condition": "[parameters('allowAzureServicesToPostgres')]",
      "type": "Microsoft.DBforPostgreSQL/flexibleServers/firewallRules",
      "apiVersion": "2023-03-01-preview",
      "name": "[format('{0}/{1}', variables('postgresServerName'), 'AllowAzure')]",
      "properties": {
        "startIpAddress": "0.0.0.0",
        "endIpAddress": "0.0.0.0"
      },
      "dependsOn": [
        "[resourceId('Microsoft.DBforPostgreSQL/flexibleServers', variables('postgresServerName'))]"
      ]
    },
    {
      "type": "Microsoft.DBforPostgreSQL/flexibleServers/databases",
      "apiVersion": "2023-03-01-preview",
      "name": "[format('{0}/{1}', variables('postgresServerName'), variables('postgresDbName'))]",
      "dependsOn": [
        "[resourceId('Microsoft.DBforPostgreSQL/flexibleServers', variables('postgresServerName'))]"
      ]
    },
    {
      "type": "Microsoft.Authorization/roleDefinitions",
      "apiVersion": "2022-04-01",
      "name": "[variables('acsSmtpCustomRoleGuid')]",
      "condition": "[variables('useAcsSmtp')]",
      "properties": {
        "roleName": "ACS Email SMTP Sender (Custom)",
        "description": "Minimal permissions to manage ACS Email SMTP username credentials as per Microsoft docs.",
        "type": "CustomRole",
        "permissions": [
          {
            "actions": [
              "Microsoft.Communication/CommunicationServices/Read",
              "Microsoft.Communication/CommunicationServices/Write",
              "Microsoft.Communication/EmailServices/write"
            ],
            "notActions": [],
            "dataActions": [],
            "notDataActions": []
          }
        ],
        "assignableScopes": [
          "[resourceGroup().id]"
        ]
      }
    },
    {
      "type": "Microsoft.Communication/emailServices",
      "apiVersion": "2025-09-01",
      "name": "[variables('acsEmailServiceName')]",
      "location": "global",
      "condition": "[variables('useAcsSmtp')]",
      "properties": {
        "dataLocation": "[parameters('acsDataLocation')]"
      }
    },
    {
      "type": "Microsoft.Communication/emailServices/domains",
      "apiVersion": "2025-09-01",
      "name": "[format('{0}/{1}', variables('acsEmailServiceName'), variables('acsDomainNameEffective'))]",
      "location": "global",
      "condition": "[variables('useAcsSmtp')]",
      "dependsOn": [
        "[resourceId('Microsoft.Communication/emailServices', variables('acsEmailServiceName'))]"
      ],
      "properties": {
        "domainManagement": "[parameters('acsDomainManagement')]",
        "userEngagementTracking": "Disabled"
      }
    },
    {
      "type": "Microsoft.Communication/emailServices/domains/senderUsernames",
      "apiVersion": "2025-09-01",
      "name": "[format('{0}/{1}/{2}', variables('acsEmailServiceName'), variables('acsDomainNameEffective'), variables('acsSenderUsername'))]",
      "condition": "[variables('useAcsSmtp')]",
      "dependsOn": [
        "[resourceId('Microsoft.Communication/emailServices/domains', variables('acsEmailServiceName'), variables('acsDomainNameEffective'))]"
      ],
      "properties": {
        "displayName": "[variables('acsSenderDisplayName')]",
        "username": "[variables('acsSenderUsername')]"
      }
    },
    {
      "type": "Microsoft.Communication/communicationServices",
      "apiVersion": "2025-09-01",
      "name": "[variables('acsCommunicationServiceName')]",
      "location": "global",
      "condition": "[variables('useAcsSmtp')]",
      "dependsOn": [
        "[resourceId('Microsoft.Communication/emailServices/domains', variables('acsEmailServiceName'), variables('acsDomainNameEffective'))]"
      ],
      "properties": {
        "dataLocation": "[parameters('acsDataLocation')]",
        "linkedDomains": [
          "[resourceId('Microsoft.Communication/emailServices/domains', variables('acsEmailServiceName'), variables('acsDomainNameEffective'))]"
        ],
        "disableLocalAuth": false,
        "publicNetworkAccess": "Enabled"
      }
    },
    {
      "type": "Microsoft.Communication/communicationServices/smtpUsernames",
      "apiVersion": "2025-09-01",
      "name": "[format('{0}/{1}', variables('acsCommunicationServiceName'), variables('acsSenderUsername'))]",
      "condition": "[variables('useAcsSmtp')]",
      "dependsOn": [
        "[resourceId('Microsoft.Communication/communicationServices', variables('acsCommunicationServiceName'))]"
      ],
      "properties": {
        "entraApplicationId": "[parameters('acsEntraApplicationId')]",
        "entraTenantId": "[parameters('acsEntraTenantId')]",
        "username": "[parameters('smtpUsername')]"
      }
    },
    {
      "type": "Microsoft.Authorization/roleAssignments",
      "apiVersion": "2022-04-01",
      "name": "[guid(resourceId('Microsoft.Communication/communicationServices', variables('acsCommunicationServiceName')), parameters('acsEntraServicePrincipalObjectId'), variables('acsSmtpCustomRoleGuid'))]",
      "condition": "[and(variables('useAcsSmtp'), not(empty(parameters('acsEntraServicePrincipalObjectId'))))]",
      "scope": "[format('Microsoft.Communication/communicationServices/{0}', variables('acsCommunicationServiceName'))]",
      "dependsOn": [
        "[resourceId('Microsoft.Authorization/roleDefinitions', variables('acsSmtpCustomRoleGuid'))]",
        "[resourceId('Microsoft.Communication/communicationServices', variables('acsCommunicationServiceName'))]"
      ],
      "properties": {
        "roleDefinitionId": "[variables('acsSmtpCustomRoleId')]",
        "principalId": "[parameters('acsEntraServicePrincipalObjectId')]",
        "principalType": "ServicePrincipal"
      }
    },
    {
      "type": "Microsoft.App/managedEnvironments",
      "apiVersion": "2024-03-01",
      "name": "[variables('containerEnvName')]",
      "location": "[parameters('location')]",
      "properties": {
        "appLogsConfiguration": {
          "destination": "log-analytics",
          "logAnalyticsConfiguration": {
            "customerId": "[reference(resourceId('Microsoft.OperationalInsights/workspaces', variables('logAnalyticsName')), '2023-09-01').customerId]",
            "sharedKey": "[listKeys(resourceId('Microsoft.OperationalInsights/workspaces', variables('logAnalyticsName')), '2023-09-01').primarySharedKey]"
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.OperationalInsights/workspaces', variables('logAnalyticsName'))]"
      ],
      "tags": "[variables('commonTags')]"
    },
    {
      "type": "Microsoft.App/managedEnvironments/storages",
      "apiVersion": "2024-03-01",
      "name": "[format('{0}/{1}', variables('containerEnvName'), 'vaultwarden-storage')]",
      "properties": {
        "azureFile": {
          "accountName": "[variables('storageAccountName')]",
          "shareName": "[variables('fileShareName')]",
          "accountKey": "[listKeys(resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName')), '2023-05-01').keys[0].value]",
          "accessMode": "ReadWrite"
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.App/managedEnvironments', variables('containerEnvName'))]",
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]",
        "[resourceId('Microsoft.Storage/storageAccounts/fileServices/shares', variables('storageAccountName'), 'default', variables('fileShareName'))]"
      ]
    },
    {
      "type": "Microsoft.App/containerApps",
      "apiVersion": "2024-03-01",
      "name": "[parameters('appName')]",
      "location": "[parameters('location')]",
      "identity": {
        "type": "UserAssigned",
        "userAssignedIdentities": {
          "[format('{0}', resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-id', parameters('appName'))))]": {}
        }
      },
      "properties": {
        "managedEnvironmentId": "[resourceId('Microsoft.App/managedEnvironments', variables('containerEnvName'))]",
        "configuration": {
          "ingress": {
            "external": true,
            "targetPort": 80,
            "allowInsecure": "[parameters('allowInsecureHttp')]"
          },
          "secrets": "[concat(variables('vwSecretsBase'), if(parameters('smtpUseAuth'), variables('vwSecretsSmtp'), json('[]')))]",
          "activeRevisionsMode": "Single"
        },
        "template": {
          "containers": [
            {
              "name": "vaultwarden",
              "image": "[parameters('vaultwardenImage')]",
              "resources": {
                "cpu": "[json(parameters('cpuCores'))]",
                "memory": "[format('{0}Gi', parameters('memorySize'))]"
              },
              "env": "[concat(variables('vwEnvBase'), variables('vwEnvSmtpCommon'), if(parameters('smtpUseAuth'), concat(variables('vwEnvSmtpAuthCore'), if(empty(parameters('smtpAuthMechanism')), json('[]'), createArray(createObject('name','SMTP_AUTH_MECHANISM','value',parameters('smtpAuthMechanism'))))), json('[]')))]",
              "volumeMounts": [
                {
                  "volumeName": "data",
                  "mountPath": "/data"
                }
              ]
            }
          ],
          "volumes": [
            {
              "name": "data",
              "storageType": "AzureFile",
              "storageName": "vaultwarden-storage"
            }
          ],
          "scale": {
            "minReplicas": "[if(parameters('startPaused'), 0, 1)]",
            "maxReplicas": 1
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-id', parameters('appName')))]",
        "[resourceId('Microsoft.App/managedEnvironments', variables('containerEnvName'))]",
        "[resourceId('Microsoft.App/managedEnvironments/storages', variables('containerEnvName'), 'vaultwarden-storage')]",
        "[resourceId('Microsoft.Resources/deploymentScripts', format('{0}-ensure-kv-secrets', parameters('appName')))]",
        "[extensionResourceId(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.KeyVault/vaults', variables('keyVaultName')), resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', format('{0}-id', parameters('appName'))), variables('roleKeyVaultSecretsUser')))]",
        "[resourceId('Microsoft.DBforPostgreSQL/flexibleServers/databases', variables('postgresServerName'), variables('postgresDbName'))]"
      ],
      "tags": "[variables('commonTags')]"
    },
    {
      "type": "Microsoft.RecoveryServices/vaults",
      "apiVersion": "2021-12-01",
      "name": "[variables('recoveryServicesVaultName')]",
      "location": "[parameters('location')]",
      "sku": {
        "name": "RS0",
        "tier": "Standard"
      },
      "properties": {},
      "condition": "[parameters('azureFilesBackupEnabled')]"
    },
    {
      "type": "Microsoft.RecoveryServices/vaults/backupPolicies",
      "apiVersion": "2021-12-01",
      "name": "[format('{0}/{1}', variables('recoveryServicesVaultName'), variables('azureFilesBackupPolicyName'))]",
      "properties": {
        "backupManagementType": "[variables('azureFilesBackupManagementType')]",
        "schedulePolicy": {
          "scheduleRunFrequency": "Daily",
          "scheduleRunTimes": "[variables('azureFilesBackupScheduleRunTimes')]",
          "schedulePolicyType": "SimpleSchedulePolicy"
        },
        "retentionPolicy": {
          "dailySchedule": {
            "retentionTimes": "[variables('azureFilesBackupScheduleRunTimes')]",
            "retentionDuration": {
              "count": "[variables('azureFilesBackupDailyRetentionDurationCount')]",
              "durationType": "Days"
            }
          },
          "weeklySchedule": {
            "daysOfTheWeek": "[variables('azureFilesBackupDaysOfTheWeek')]",
            "retentionTimes": "[variables('azureFilesBackupScheduleRunTimes')]",
            "retentionDuration": {
              "count": "[variables('azureFilesBackupWeeklyRetentionDurationCount')]",
              "durationType": "Weeks"
            }
          },
          "retentionPolicyType": "LongTermRetentionPolicy"
        },
        "timeZone": "[variables('azureFilesBackupTimeZone')]",
        "workLoadType": "AzureFileShare"
      },
      "dependsOn": [
        "[resourceId('Microsoft.RecoveryServices/vaults', variables('recoveryServicesVaultName'))]"
      ],
      "condition": "[parameters('azureFilesBackupEnabled')]"
    },
    {
      "type": "Microsoft.RecoveryServices/vaults/backupFabrics/protectionContainers",
      "apiVersion": "2021-12-01",
      "name": "[format('{0}/{1}/storagecontainer;Storage;{2};{3}', variables('recoveryServicesVaultName'), variables('azureFilesBackupFabric'), resourceGroup().name, variables('storageAccountName'))]",
      "properties": {
        "backupManagementType": "[variables('azureFilesBackupManagementType')]",
        "containerType": "StorageContainer",
        "sourceResourceId": "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      },
      "dependsOn": [
        "[resourceId('Microsoft.RecoveryServices/vaults', variables('recoveryServicesVaultName'))]",
        "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]"
      ],
      "condition": "[parameters('azureFilesBackupEnabled')]"
    },
    {
      "type": "Microsoft.RecoveryServices/vaults/backupFabrics/protectionContainers/protectedItems",
      "apiVersion": "2021-12-01",
      "name": "[format('{0}/{1}/{2}/{3}', split([format('{0}/{1}/storagecontainer;Storage;{2};{3}', variables('recoveryServicesVaultName'), variables('azureFilesBackupFabric'), resourceGroup().name, variables('storageAccountName'))], '/')[0], split([format('{0}/{1}/storagecontainer;Storage;{2};{3}', variables('recoveryServicesVaultName'), variables('azureFilesBackupFabric'), resourceGroup().name, variables('storageAccountName'))], '/')[1], split([format('{0}/{1}/storagecontainer;Storage;{2};{3}', variables('recoveryServicesVaultName'), variables('azureFilesBackupFabric'), resourceGroup().name, variables('storageAccountName'))], '/')[2], format('AzureFileShare;{0}', variables('fileShareName')))]",
      "properties": {
        "protectedItemType": "AzureFileShareProtectedItem",
        "sourceResourceId": "[resourceId('Microsoft.Storage/storageAccounts', variables('storageAccountName'))]",
        "policyId": "[resourceId('Microsoft.RecoveryServices/vaults/backupPolicies', variables('recoveryServicesVaultName'), variables('azureFilesBackupPolicyName'))]",
        "isInlineInquiry": true
      },
      "dependsOn": [
        "[resourceId('Microsoft.RecoveryServices/vaults/backupPolicies', variables('recoveryServicesVaultName'), variables('azureFilesBackupPolicyName'))]",
        "[resourceId('Microsoft.RecoveryServices/vaults/backupFabrics/protectionContainers', split([format('{0}/{1}/storagecontainer;Storage;{2};{3}', variables('recoveryServicesVaultName'), variables('azureFilesBackupFabric'), resourceGroup().name, variables('storageAccountName'))], '/')[0], split([format('{0}/{1}/storagecontainer;Storage;{2};{3}', variables('recoveryServicesVaultName'), variables('azureFilesBackupFabric'), resourceGroup().name, variables('storageAccountName'))], '/')[1], split([format('{0}/{1}/storagecontainer;Storage;{2};{3}', variables('recoveryServicesVaultName'), variables('azureFilesBackupFabric'), resourceGroup().name, variables('storageAccountName'))], '/')[2])]",
        "[resourceId('Microsoft.RecoveryServices/vaults', variables('recoveryServicesVaultName'))]",
        "[resourceId('Microsoft.Storage/storageAccounts/fileServices/shares', variables('storageAccountName'), 'default', variables('fileShareName'))]"
      ],
      "condition": "[parameters('azureFilesBackupEnabled')]"
    }
  ],
  "outputs": {
    "containerAppFqdn": {
      "type": "string",
      "value": "[reference(resourceId('Microsoft.App/containerApps', parameters('appName')), '2024-03-01').configuration.ingress.fqdn]"
    },
    "keyVaultName": {
      "type": "string",
      "value": "[variables('keyVaultName')]"
    },
    "acsEnabled": {
      "type": "bool",
      "value": "[variables('useAcsSmtp')]"
    },
    "acsCommunicationServiceName": {
      "type": "string",
      "value": "[if(variables('useAcsSmtp'), variables('acsCommunicationServiceName'), '')]"
    },
    "acsEmailServiceName": {
      "type": "string",
      "value": "[if(variables('useAcsSmtp'), variables('acsEmailServiceName'), '')]"
    },
    "acsEmailDomain": {
      "type": "string",
      "value": "[if(variables('useAcsSmtp'), variables('acsDomainNameEffective'), '')]"
    },
    "smtpServerResolved": {
      "type": "string",
      "value": "[if(variables('useAcsSmtp'), 'smtp.azurecomm.net:587', if(parameters('smtpUseAuth'), concat(if(empty(parameters('smtpHost')), 'smtp.office365.com', parameters('smtpHost')), ':', string(parameters('smtpPort'))), concat(reference(resourceId('Microsoft.Resources/deploymentScripts', variables('deploymentScriptName')), variables('deploymentScriptApiVersion')).outputs.smtp_host, ':25')))]"
    }
  }
}